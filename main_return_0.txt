Even if you don't #include any headers in your source code, the code you type in is not the only code that ends up in the program---the C compiler still links in the C language runtime. There is some stuff going on behind the scenes that you don't normally have to think about.

The C runtime contains initialization and clean-up code. These are platform-dependent, but to give a rough idea of what goes on I will explain what happens in Linux. First, a parent process calls fork(), which causes the kernel to clone it into a child process. The child process calls execve() with the path to a new program to be executed, with arguments (argv) and environment variables (envp).

If the program executed is a binary, it will contain in its header somewhere an address where execution begins. This is not the address of main(). Instead, execution begins in the C runtime. By the time execution has begun, the values of argc, argv, and envp have already been copied directly into registers by the kernel. The initialization code does various (implementation-dependent) things to get the program ready to execute main(). Then it calls main() with the argc, argv, and envp values, just like how main() calls other functions (in any reasonably sized program).

When a function returns, the return value is passed back to the code that called it, usually through a register; this, too, is what becomes of main(), whose return value is passed to the C runtime. The runtime then calls all atexit() handlers in reverse order of registration. Finally, it performs its own (implementation-dependent) cleanup, and calls _exit(), passing the return value to the kernel and asking it to terminate the process. The kernel holds this value in memory until the parent process asks for it using the wait() call or something similar. The kernel returns the return value to the parent process, and finally removes the child process from the process table.